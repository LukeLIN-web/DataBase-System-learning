#  Database notebook

作业答案： https://wenku.baidu.com/view/69529f1aaf1ffc4ffe47acd9.html

### lec8存储和数据结构

cache 最快， 0.5 ns

内存 10-100ns  比磁盘大概快100万倍。

flash ， 读可以和内存差不多， 写10us。 

SATA 150MB/s，

 RAID0 ， 没有重复

RAID1 ， 1比1 备份。

RAID5 ， N+1 存N个。 

#### buffer manager

替换策略

LRU的块可能是下面快要用的块(循环)，而最近刚用过的块则暂时不用，当空间不够时倒是可以将其覆盖的, 故LRU策略不佳。MRU strategy (Most recently used, 最近最常用策略反而比较好。

Toss-immediate  strategy用后立即free space

#### 文件组织

固定长度记录还是变长记录



   

##### 顺序存储

需要定期对文件重新排序

多表Multitable Clustering File Organization

有助于联合查询，不利于单个表查询。 



## lec9 



### B+树

在 B+树中删除关键字时，有以下几种情况：

1、 找到存储有该关键字所在的结点时，由于该结点中关键字个数大于`⌈M/2⌉`，做删除操作不会破坏 B+树，则可以直接删除。

删除关键字 `91`，包含关键字 `91` 的结点 `[85、91、97]` 中关键字的个数 3 大于 `⌈M/2⌉ = 2` ，做删除操作不会破坏 B+树的特性，直接删除。

 当删除某结点中最大或者最小的关键字，就会涉及到更改其双亲结点一直到根结点中所有索引值的更改。

当删除该关键字，导致当前结点中关键字个数小于 `⌈M/2⌉`，若其兄弟结点中含有多余的关键字，可以从兄弟结点中借关键字完成删除操作。

当删除某个关键字之后，结点中关键字个数小于 `⌈M/2⌉` ，则不符合 B+树的特性，则需要按照 3 he 4 两种情况分别处理。以删除关键字  `51` 为例，由于其兄弟结点 `[21、37、44]` 中含有 3 个关键字，所以可以选择借一个关键字 `44`，同时将双亲结点中的索引值 `44` 修改 `37` ，删除过程如下图所示：

第 3 种情况中，如果其兄弟结点没有多余的关键字，则需要同其兄弟结点进行合并。

当进行合并时，可能会产生因合并使其双亲结点破坏 B+树的结构，需要依照以上规律处理其双亲结点。如果父亲节点删除了， 那就要把爷爷和另一边树的叔叔合并。 



小测考点: 

知道item数量, 求node 数量和高度.





### LSM 树

Log structured merge tree

B+树对于SSD上的数据并不友好. 

内存优化的LSM树. 插入速度快, 查找很慢. 

L0树在内存中, 磁盘里有多个越来越大的B+树, 是上一层的K倍.

##### 插入

首先写到L0 tree.

 L0 达到阈值的时候merge到L1,   L1达到阈值的时候merge到L2, 

update 要从上到底全部update.  这样太慢了, 策略是插入一个新的值.  然后如果上面有新的值, 下面的就废弃了.merge的时候清理无效的数据.

#### stepped merge index

现在很多插入密集型的数据库都用这个方法.

如果需要频繁merge, 方法是把大的L1 拆成多个小B+树.

这个策略甚至可以不merge, 直接在下一级生成一个小的B+树, 然后等一级全部满了再merge 到下一级. 

缺点: 算法实现更加麻烦.  

##### 查找

很慢, 可以用布隆过滤器Bloom Filter优化. 要查找之前可以先在布隆过滤器查找, 如果存在再在L树查找, 如果不存在那么L树也不存在

还有一种buffer tree

在internal node中保留一段buffer, 存插入的索引项, 减少下面的IO操作. 



## lec10 查询处理和优化

作业答案:

https://www.db-book.com/db6/practice-exer-dir/12s.pdf

1. 语法分析和翻译
2. 优化
3. 执行

sjl 5月7日 第六节课.  5.10日

线性搜索。ts + br * tT 一次搜索, 然后br次 传输, 假设是连续存放的. 要把整个文件都塞到内存中.

索引搜索 : (hi+1) * ( t T+ ts)。hi 代表索引的高度.

什么是磁盘搜索?
考点:

### 连接运算


考点:连接运算

这些好像很难理解, 还是背诵吧. 

 r 记录10000 ,  磁盘块数。400 

s 记录 5000,  磁盘块数, 100 

Estimate the number of block transfers and seeks required using each of the following join strategies 

#### Nested-loop join  嵌套循环连接

```python
for  tr in r :
	for ts in s :
        if tr, ts 满足条件: 
            加入结果
```

要检查  nr *ns = 10000 乘 5000 个元组

最坏 , 块要传输,  nr * bs + br ,    就是包含r的都要传输, 然后对于每个r中的元组, 要传输包含s的各个块.  搜索, 读取r的次数, 然后包含r的次数.  

br是包括r中tuple的块数,   nr是r中的tuple数. 

#### Block nested-loop join 

```
for each Br in r:
	for each Bs in s:
        for tr in Br :
            for ts in Bs :
                if tr, ts 满足条件: 
                    加入结果
```

最坏情况下,  br * bs + br 次块传输. 

假设都是连续放置的, 

#### Merge join 

归并连接

#### Hash join



## 查询优化

1. 产生一个逻辑上等价的表达式
2. 如何估计每个操作结果集的统计大小
3. 如何选择代价较小的计划

### 表达式的转换

#### 等价规则

1. 选择运算 可以级联
2. 选择运算满足交换律
3. 投影的级联, 只有最后一个是必须的.
4. 选择可以和笛卡尔积以及θ连接结合
5. θ连接满足交换律和结合律
6. 自然连接满足结合律. 笛卡尔积也满足.
7. 选择操作在下面两个条件成立时满足分配律
   - 选择条件只涉及左边或者只涉及右边
   - 选择条件1只涉及左边, 选择条件2 只涉及右边

8. 投影运算在两个条件成立时对theta连接有分配律


### 统计大小估计

#### 直方图估计

有等宽直方图和等深直方图,  不同属性上的直方图可以存储在系统目录里. 这样优化器就可以知道属性值的分布. 
