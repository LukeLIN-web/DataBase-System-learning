<div class="cover" style="page-break-after:always;font-family:方正公文仿宋;width:100%;height:100%;border:none;margin: 0 auto;text-align:center;">
    <div style="width:60%;margin: 0 auto;height:0;padding-bottom:10%;">
        </br>
        <img src="file:///Users/lvdanyu/Desktop/db/%E6%8A%A5%E5%91%8A/%E6%A0%A1%E5%90%8D-%E9%BB%91%E8%89%B2.svg" alt="校名" style="width:100%;"/>
    </div>
    </br></br></br></br></br>
    <div style="width:60%;margin: 0 auto;height:0;padding-bottom:40%;">
        <img src="file:///Users/lvdanyu/Desktop/db/%E6%8A%A5%E5%91%8A/%E6%A0%A1%E5%BE%BD-%E9%BB%91%E8%89%B2.svg" alt="校徽" style="width:100%;"/>
	</div>
    </br></br></br></br></br></br></br></br>
    <span style="font-family:华文黑体Bold;text-align:center;font-size:20pt;margin: 10pt auto;line-height:30pt;">《MiniSQL总体设计报告》</span>
    <p style="text-align:center;font-size:14pt;margin: 0 auto">课程作业报告 </p>
    </br>
    </br>
    <table style="border:none;text-align:center;width:72%;font-family:仿宋;font-size:14px; margin: 0 auto;">
    <tbody style="font-family:方正公文仿宋;font-size:12pt;">
    	<tr style="font-weight:normal;"> 
    		<td style="width:20%;text-align:right;">题　　目</td>
    		<td style="width:2%">：</td> 
    		<td style="width:40%;font-weight:normal;border-bottom: 1px solid;text-align:center;font-family:华文仿宋"> MiniSQL总体设计报告</td>     </tr>
    	<tr style="font-weight:normal;"> 
    		<td style="width:20%;text-align:right;">上课时间</td>
    		<td style="width:2%">：</td> 
    		<td style="width:40%;font-weight:normal;border-bottom: 1px solid;text-align:center;font-family:华文仿宋"> 周二下午</td>     </tr>
    	<tr style="font-weight:normal;"> 
    		<td style="width:20%;text-align:right;">授课教师</td>
    		<td style="width:2%">：</td> 
    		<td style="width:40%;font-weight:normal;border-bottom: 1px solid;text-align:center;font-family:华文仿宋">陈刚 </td>     </tr>
    	<tr style="font-weight:normal;"> 
    		<td style="width:20%;text-align:right;">日　　期</td>
    		<td style="width:2%">：</td> 
    		<td style="width:40%;font-weight:normal;border-bottom: 1px solid;text-align:center;font-family:华文仿宋">完成日期</td>     </tr>
    </tbody>              
    </table>
</div>

<!-- 注释语句：导出PDF时会在这里分页 -->


# **MiniSQL总体设计报告**

## MiniSQL系统概述

### 背景

#### 编写目的

1. 设计并实现一个精简型单用户SQL引擎MiniSQL，允许用户通过字符界面输入SQL语句实现基本的增删改查操作，并能够通过索引来优化性能。
2. 通过对MiniSQL的设计与实现，提高学生的系统编程能力，加深对数据库管理系统底层设计的理解。

#### 项目背景



###  功能描述

1. 数据类型：要求支持三种基本数据类型：`integer`，`char(n)`，`float`。
2. 表定义：一个表可以定义多达32个属性，各属性可以指定是否为`unique`，支持单属性的主键定义。
3. 索引定义：对于表的主属性自动建立B+树索引，对于声明为`unique`的属性也需要建立B+树索引。
4. 数据操作: 可以通过`and`或`or`连接的多个条件进行查询，支持等值查询和区间查询。支持每次一条记录的插入操作；支持每次一条或多条记录的删除操作。
5. 在工程实现上，使用源代码管理工具（Git-Lab）进行代码管理，代码提交历史和每次提交的信息清晰明确；同时编写的代码应符合代码规范，具有良好的代码风格。



### 运行环境和配置

- `apple clang`: 11.0+ (MacOS)，使用`gcc --version`和`g++ --version`查看
- `gcc`&`g++` : 8.0+ (Linux)，使用`gcc --version`和`g++ --version`查看
- `cmake`: 3.16+ (Both)，使用`cmake --version`查看
- `gdb`: 7.0+ (Optional)，使用`gdb --version`查看
- `flex`& `bison`(暂时不需要安装，但如果需要对SQL编译器的语法进行修改，需要安装）

本组：

 Windows10，WSL2，x86_64-linux-gnu Ubuntu 20.04，环境配置 g++ 9.4.0，gdb， IDE：CLion



###   参考资料

1. 语雀文档📖：https://www.yuque.com/yingchengjun/pcp6qx/fggii4
2. 链接🔗：http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf
3. CMU网课🌲：https://www.bilibili.com/video/BV1VL411w72p?p=5 



##    MiniSQL系统结构设计

###  总体设计：

#### 系统架构示意图

- 在系统架构中，解释器`SQL Parser`在解析SQL语句后将生成的语法树交由执行器`Executor`处理。执行器则根据语法树的内容对相应的数据库实例（`DB Storage Engine Instance`）进行操作。
- 每个`DB Storage Engine Instance`对应了一个数据库实例（即通过`CREATE DATABSAE`创建的数据库）。在每个数据库实例中，用户可以定义若干表和索引，表和索引的信息通过`Catalog Manager`、`Index Manager`和`Record Manager`进行维护。目前系统架构中已经支持使用多个数据库实例，不同的数据库实例可以通过`USE`语句切换（即类似于MySQL的切换数据库），在初步实现时，可以先考虑单个数据库实例的场景，在单个实例跑通后再支持多个实例。

<img src="https://cdn.nlark.com/yuque/0/2022/png/25540491/1648365471553-1ceac0a4-e909-42c8-8bb9-516409e03492.png" alt="image.png" style="zoom:50%;" />

### DISK AND BUFFER POOL MANAGER 模块：

​	Disk Manager和Buffer Pool Manager模块位于架构的最底层。Disk Manager主要负责数据库文件中数据页的分配和回收，以及数据页中数据的读取和写入。其中，数据页的分配和回收通过位图（Bitmap）这一数据结构实现，位图中每个比特（Bit）对应一个数据页的分配情况，用于标记该数据页是否空闲（`0`表示空闲，`1`表示已分配）。当Buffer Pool Manager需要向Disk Manager请求某个数据页时，Disk Manager会通过某种映射关系，找到该数据页在磁盘文件中的物理位置，将其读取到内存中返还给Buffer Pool Manager。而Buffer Pool Manager主要负责将磁盘中的数据页从内存中来回移动到磁盘，这使得我们设计的数据库管理系统能够支持那些占用空间超过设备允许最大内存空间的数据库。

​	Buffer Pool Manager中的操作对数据库系统中其他模块是透明的。例如，在系统的其它模块中，可以使用数据页唯一标识符`page_id`向Buffer Pool Manager请求对应的数据页。但实际上，这些模块并不知道该数据页是否已经在内存中还是需要从磁盘中读取。同样地，Disk Manager中的数据页读写操作对Buffer Pool Manager模块也是透明的，即Buffer Pool Manager使用逻辑页号`logical_page_id`向Disk Manager发起数据页的读写请求，但Buffer Pool Manager并不知道读取的数据页实际上位于磁盘文件中的哪个物理页（对应页号`physical_page_id`）。

### RECORD MANAGER 模块：

​	Record Manager负责管理数据表中所有的记录，它能够支持记录的插入、删除与查找操作，并对外提供相应的接口。

与记录（Record）相关的概念有以下几个：

- 列（`Column`）：在`src/include/record/column.h`中被定义，用于定义和表示数据表中的某一个字段，即包含了这个字段的字段名、字段类型、是否唯一等等；
- 模式（`Schema`）：在`src/include/record/schema.h`中被定义，用于表示一个数据表或是一个索引的结构。一个`Schema`由一个或多个的`Column`构成；
- 域（`Field`）：在`src/include/record/field.h`中被定义，它对应于一条记录中某一个字段的数据信息，如存储数据的数据类型，是否是空，存储数据的值等等；
- 行（`Row`）：在`src/include/record/row.h`中被定义，与元组的概念等价，用于存储记录或索引键，一个`Row`由一个或多个`Field`构成。

### INDEX MANAGER 模块：

​	Index Manager 负责数据表索引的实现和管理，包括：索引的创建和删除，索引键的等值查找，索引键的范围查找（返回对应的迭代器），以及插入和删除键值等操作，并对外提供相应的接口。

​	在上一个实验中，同学们应该能够发现，通过遍历堆表的方式来查找一条记录是十分低效的。为了能够快速定位到某条记录而无需搜索数据表中的每一条记录，我们需要在上一个实验的基础上实现一个索引，这能够为快速随机查找和高效访问有序记录提供基础。索引有很多种实现方式，如B+树索引，Hash索引等等。在本实验中，需实现一个基于磁盘的B+树动态索引结构。

### CATALOG MANAGER 模块：

​	Catalog Manager 负责管理和维护数据库的所有模式信息，包括：

- 数据库中所有表的定义信息，包括表的名称、表中字段（列）数、主键、定义在该表上的索引。
- 表中每个字段的定义信息，包括字段类型、是否唯一等。
- 数据库中所有索引的定义，包括所属表、索引建立在那个字段上等。

这些模式信息在被创建、修改和删除后还应被持久化到数据库文件中。此外，Catalog Manager还需要为上层的执行器Executor提供公共接口以供执行器获取目录信息并生成执行计划。

### SQL EXECUTOR 模块：

​	Executor（执行器）的主要功能是根据解释器（Parser）生成的语法树，通过Catalog Manager 提供的信息生成执行计划，并调用 Record Manager、Index Manager 和 Catalog Manager 提供的相应接口进行执行，最后通过执行上下文`ExecuteContext`将执行结果返回给上层模块。



## 测试方案和测试样例

（这部分主要针对上面程序功能来设计测试案例）

使用框架提供的测试。 part5使用yuque提供的 sql.txt， 利用execfile进行测试。 

## 分组与设计分工

### 模块一：DISK AND BUFFER POOL MANAGER (合作



### 模块二：RECORD MANAGER(个人)



### 模块三：INDEX MANAGER（合作）

### 模块四：CATALOG MANAGER(个人)

### 模块五：SQL EXECUTOR（合作）

（该部分是本文档的重点，每个模块需要列出包含的数据结构和接口，以及与其他模块的交互方式，具体的实现细节请在个人详细报告中描述，必须要有软件体系结构图）

### 实现细节

#### disk manager 

1. 构造函数，打开文件

2. 析构函数， 关闭fstream

3.  findExtentPhyId ， 找到extent的physical id。这是用来读入和写入extent

4.   AllocateExtent 写入一个新的extent bitmap，不要让函数产生副作用，不修改metapage 

5.  allocatepage ， 从文件中读取bitmap, 定位extent. 利用bitmap的函数分配page. 

   如果成功, 更新extent。 失败了, 新建extent, 分配page.

伪代码如下:

```python
if  getfileSize == 0:
    writeMetapage  # 不能直接写入offset 过大的 
if 达到最大page:
    return -1;
if extentnum ==0:
    allocateextent
    更新metapage
buf 页读取bitmap
newpage页作为初始化的数据页
找到bitmap
if bitmap-》allocatepage == true:
    写回bitmap
    写入新page
    更新metapage
    return 
else:
    if allocateextent 失败:
        return
    else:
        重新尝试分配page
        更新metapage
        return 
```

6. DiskManager::DeAllocatePage(logical_page_id)：释放磁盘中**逻辑页号**对应的物理页。 

伪代码如下

```
if  page 不为空:
    打印错误
    return 
读取bitmap
bitmap->deallocate 
更新meta 
```

7. DiskManager::IsPageFree(logical_page_id)：判断该**逻辑页号**对应的数据页是否空闲。 找到extent,利用bitmap is page free 判断是否为空

8. DiskManager::MapPageId(logical_page_id)：可根据需要实现。在DiskManager类的私有成员中，该函数可以用于将逻辑页号转换成物理页号。

#### index iterator

1. 构造函数， leaf = reinterpret_cast<LeafPage *>(page_->GetData()); 需要page来获得pageid， 也需要leaf类GetNextPageId
2. 析构函数， 做一个unpin。
3.  operator* 返回leaf的item。
4. isend ： return leaf->GetNextPageId() == INVALID_PAGE_ID and idx == leaf->GetSize(); 
5.  重载操作符++，   如果在同一页， 就加idx。 超出了就到下一个page。 
6. 重载操作符==， 一开始我以为要取数据， 后来比较pageid和idx相等就可以了。
7. 重载操作符！=， 可以直接用上面已经重载的== 。

### part5 执行器

##### 构造函数

利用 std::filesystem::directory_iterator 遍历文件夹， 根据文件名字新建DBStorageEngine 实例，插入到dbs_。

##### execute

根据ast 根节点的类型， 选择对应的执行方法。

##### database

createdatabase

创建文件，创建实例，插入到dbs_

dropdatabase

先delete 实例，再调用dbs_.erase

showdatabase 

遍历dbs。 `dbs_name.push_back(db.first.substr(path.find('\\') + 1));`

use database 

修改current_db_

##### showtables

调用catalog_mgr_的gettables方法。

##### create table

首先判断table是否存在。

从语法树得到primary keys， 加入到primary和index vector中。

从语法树得到column names，判断char的长度可以用try stoi catch。 就可以利用stoi的判断不用自己判断。 

然后创建primary key 的index。

##### droptable

调用catalog_mgr_->DropTable

##### showindex

获得所有tableinfo， 遍历所有table， 找到所有index。

##### createindex

调用 catalog->CreateIndex

##### dropindex

调用catalog->DropIndex

##### select

从语法树提取条件存到vector中。 获得列 tableInfo->GetSchema()->GetColumns() 如果不走索引， 对于每一行判断，

1. 选所有列， 遍历columns，获得(*it).GetField(i); getdata。我们重写了getdata，对类型进行判断。 
2. 选部分列， 我们获得列的index， 然后取值。

如果选部分行。 通过条件判断选还是不选， 选就按上面的取值， 不选就下一行。 

##### insert

根据语法树生成fields， 获得table的 memheap， 生成row。 table_heap->InsertTuple

##### delete

从语法树提取条件存到vector中。 获得列 tableInfo->GetSchema()->GetColumns() 如果不走索引， 对于每一行判断，如果符合条件把rid加入vector。

最后删除applydelete所有rid对应的行。

##### update

获得所有condition，获得新的各个列名和值。

update all：  获得每行， 如果列名一样， 那就是新的， 否则就是老的。 UpdateTuple。

根据condition update

##### execfile

复制main中的循环代码， 读取文件一行行进行执行。 

##### judge

最外层遍历or，有一个相等就成立

内层遍历and， 有一个不等就break；

colname找到列， 列找到field， 判断val是否相等。

怎么找到列？先根据schema建立name 到 colposition的map。 我直接修改schema轮询所有列了， 只适用于列不多的情况。 这个框架封装的不好， 没有提供map。

怎么找到schema？













**参考文献:** 

